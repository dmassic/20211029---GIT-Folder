/JOB
//NAME SR1-EDG3
//POS
///NPOS 0,0,0,0,0,0
//INST
///DATE 2018/07/11 10:29
///COMM Edge Detection
///ATTR SC,RW,MC
///GROUP1 RB1
///GROUP2 ST3
///LVARS 19,18,26,20,0,31,0,31
NOP
'!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
'THIS VERSION CONTAIN A NEW
'ARGUMENT (14) WHICH SPECIFY
'TO USE OR NOT
'THE PLANE FINDER FUNCTION
'!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
'----------------------------
'----- DX -------------------
'--- ver.1.7.1 --------------
'--- Yaskawa America Inc. ---
'--- Motoman Robotic Div. ---
'--- 2014DEC18 TL ----------
'----------------------------
' 
'- For use with Touch Sensing
'-  and/or 1D laser sensor
' 
'--------------------------------
' 
'--------------------------------
'---- Setup Section ... begin ---
'--------------------------------
' 
'RESET THE NUMBER OF RETRY BYTE
SET LB015 0
*RETRY
'LI8 = Robot Number (ie. R1)
SET LI008 1
' 
'If using a laser sensor instead
' of touch sense, LI13 = rapid
' input # for laser sensor. Set
' LI13 to 0 if touch sensing is
' used.
SET LI013 0
' 
' output laser is wired to
SET LI014 21
' 
'LI6 = auto teach offset
SET LI006 10
SET LD000 LI006
' 
'LB11 = speed type
SET LB011 2
' 1 = mm/sec
' 2 = cm/min
' 3 = inch/min
' 4 = mm/min
' 
'LI0 = non search speed
SET LI000 1000
' 
'LB7 = userframe number
SET LB007 0
'--------------------------------
'MAXIMUM PERMISIV SHIFTED RESULT
'SET LR018 IN M.M.
'--------------------------------
SET LR018 1.5
SET LD015  EXPRESS LR018 * 1000
'-----------------------------
'SET THE NEGATIVE MAXIMUM VALUE
'-----------------------------
SET LD019  EXPRESS -LD015
' 
'LD22 = gap adjustment (microns)
SET LD022 1500
' 
'--------------------------------
'-- Setup Section ... complete --
'--------------------------------
'--- Do not modify below here ---
'--------------------------------
' 
' 
GETS LPX000 $PX000
SET LEX001 LEX000
SET LEX002 LEX000
SET LEX003 LEX000
'--------------------------------
' Initialize Variables
'--------------------------------
' 
' Rapid Input number
GETARG LI004 IARG#(16)
'SPECIFY IF WE USE OR NOT
'THE PLANE FINDER FUNCTION
GETARG LB013 IARG#(14)
'--------------------------------
'RETRY THE SEARCH IF
'THE SHIFT RESULT IS
'HIGHTIER THAN THE MAX
'SET VALUE
'SET LB014 THE # OF RETRY
'--------------------------------
SET LB014 2
' 
' check variable settings
' 
JUMP *ngFrame IF LB007<0
JUMP *ngFrame IF LB007>64
JUMP *ngSpdtyp IF LB011<1
JUMP *ngSpdtyp IF LB011>4
JUMP *ngSpeed2 IF LI000<1
JUMP *ngSpeed2 IF LI000>3000
JUMP *ngRIN IF LI004<1
JUMP *ngRIN IF LI004>5
JUMP *ngAteach IF LI006<1
JUMP *ngAteach IF LI006>100
JUMP *ngRobot IF LI008<1
JUMP *ngRobot IF LI008>4
JUMP *ngLaser IF LI013<0
JUMP *ngLaser IF LI013>5
JUMP *ngSpeed2 IF LI000<1
JUMP *ngSpeed2 IF LI000>4500
JUMP *ngGapAdj IF LD022<0
JUMP *ngGapAdj IF LD022>5000
' 
' set I/O for Robots
' 
JUMP *R1 IF LI008=1
JUMP *R2 IF LI008=2
JUMP *R3 IF LI008=3
JUMP *R4 IF LI008=4
' 
*R1
SET LI009 1861
SET LI010 1862
SET LI011 1863
SET LI012 1864
JUMP *RIN1R1 IF LI004=1
JUMP *RIN2R1 IF LI004=2
JUMP *RIN3R1 IF LI004=3
JUMP *RIN4R1 IF LI004=4
JUMP *RIN5R1 IF LI004=5
*RIN1R1
SET LI007 1841
JUMP *RINSET1
*RIN2R1
SET LI007 1842
JUMP *RINSET1
*RIN3R1
SET LI007 1843
JUMP *RINSET1
*RIN4R1
SET LI007 1844
JUMP *RINSET1
*RIN5R1
SET LI007 1845
*RINSET1
JUMP *RBTSET
*R2
SET LI009 1857
SET LI010 1858
SET LI011 1859
SET LI012 1860
JUMP *RIN1R2 IF LI004=1
JUMP *RIN2R2 IF LI004=2
JUMP *RIN3R2 IF LI004=3
JUMP *RIN4R2 IF LI004=4
JUMP *RIN5R2 IF LI004=5
*RIN1R2
SET LI007 1833
JUMP *RINSET2
*RIN2R2
SET LI007 1834
JUMP *RINSET2
*RIN3R2
SET LI007 1835
JUMP *RINSET2
*RIN4R2
SET LI007 1836
JUMP *RINSET2
*RIN5R2
SET LI007 1837
*RINSET2
JUMP *RBTSET
*R3
SET LI009 1853
SET LI010 1854
SET LI011 1855
SET LI012 1856
JUMP *RIN1R3 IF LI004=1
JUMP *RIN2R3 IF LI004=2
JUMP *RIN3R3 IF LI004=3
JUMP *RIN4R3 IF LI004=4
JUMP *RIN5R3 IF LI004=5
*RIN1R3
SET LI007 1825
JUMP *RINSET3
*RIN2R3
SET LI007 1826
JUMP *RINSET3
*RIN3R3
SET LI007 1827
JUMP *RINSET3
*RIN4R3
SET LI007 1828
JUMP *RINSET3
*RIN5R3
SET LI007 1829
*RINSET3
JUMP *RBTSET
*R4
SET LI009 1849
SET LI010 1850
SET LI011 1851
SET LI012 1852
JUMP *RIN1R4 IF LI004=1
JUMP *RIN2R4 IF LI004=2
JUMP *RIN3R4 IF LI004=3
JUMP *RIN2R4 IF LI004=4
JUMP *RIN3R4 IF LI004=5
*RIN1R4
SET LI007 1817
JUMP *RINSET4
*RIN2R4
SET LI007 1818
JUMP *RINSET4
*RIN3R4
SET LI007 1819
JUMP *RINSET4
*RIN4R4
SET LI007 1820
JUMP *RINSET4
*RIN5R4
SET LI007 1821
*RINSET4
*RBTSET
' 
JUMP *NO_LASER IF LI004<>LI013
'********************************
'OPEN LASER DOOR
'********************************
DOUT OT#(21) ON
TIMER T=0.20
'********************************
DOUT OT#(LI014) ON
*NO_LASER
' 
DOUT OT#(LI007) ON
'signal delay time
TIMER T=0.10
' 
'--------------------------------
' Initialize complete
'--------------------------------
' 
MSG ""
' 
' teach mode?
GETARG LB004 IARG#(1)
' LB4=0 ... playback
' LB4=1 ... autodetect ref2
' LB4=2 ... autodetect ref3
JUMP *ngTeach IF LB004>2
' 
'RefPoint1
GETARG LP001 IARG#(2)
'start point ST
GETARG LEX001 IARG#(3)
CNVRT LPX001 LPX001 BF
SET LEX000 LEX001
GETE LD005 LP001 (1)
JUMP *P1_OK IF LD005<>0
GETE LD005 LP001 (2)
JUMP *P1_OK IF LD005<>0
GETE LD005 LP001 (3)
JUMP *P1_OK IF LD005<>0
JUMP *ngPos
*P1_OK
' 
'RefPoint2
GETARG LP002 IARG#(4)
' 1st detect ST
GETARG LEX002 IARG#(5)
CNVRT LPX002 LPX002 BF
GETE LD005 LP002 (1)
JUMP *P2_OK IF LD005<>0
GETE LD005 LP002 (2)
JUMP *P2_OK IF LD005<>0
GETE LD005 LP002 (3)
JUMP *P2_OK IF LD005<>0
JUMP *ngPos
*P2_OK
' 
'RefPoint3
GETARG LP003 IARG#(6)
' edge detect ST
GETARG LEX003 IARG#(7)
CNVRT LPX003 LPX003 BF
' 
GETE LD005 LP003 (1)
JUMP *P3_OK IF LD005<>0
GETE LD005 LP003 (2)
JUMP *P3_OK IF LD005<>0
GETE LD005 LP003 (3)
JUMP *P3_OK IF LD005<>0
JUMP *ngPos
*P3_OK
' 
' search speed
GETARG LI001 IARG#(8)
JUMP *ngSpeed IF LI001<1
JUMP *ngSpeed IF LI001>1000
JUMP *S1 IF LB011=1
JUMP *S2 IF LB011=2
JUMP *S3 IF LB011=3
JUMP *S4 IF LB011=4
' 
*S1
' mm/sec
MUL LI000 10
MUL LI001 10
JUMP *SSET
*S2
' cm/min
SET LI000  EXPRESS LI000 / 0.599
SET LI001  EXPRESS LI001 / 0.599
JUMP *SSET
*S3
' inch/min
SET LI000  EXPRESS LI000 / 0.599 / 0.392
SET LI001  EXPRESS LI001 / 0.599 / 0.392
JUMP *SSET
*S4
' mm/min
SET LI000  EXPRESS LI000 / 5.99
SET LI001  EXPRESS LI001 / 5.99
*SSET
' 
' step offset
GETARG LR002 IARG#(9)
JUMP *ngStep IF LR002<0
JUMP *ngStep IF LR002>100
SET LD002 LR002
' 
' depth
GETARG LR003 IARG#(10)
JUMP *ngDepth IF LR003<=0
JUMP *ngDepth IF LR003>20
SET LD003  EXPRESS LR003 * 10
' 
' max search dist
GETARG LD001 IARG#(11)
JUMP *ngDist IF LD001<1
JUMP *ngDist IF LD001>100
MUL LD001 10
SET LD014  EXPRESS LD001 * 100
' 
' Ouput Shift Pvar no.
GETARG LI002 IARG#(12)
JUMP *ngOutP IF LI002<0
JUMP *ngOutP IF LI002>127
' 
' pattern type
GETARG LI003 IARG#(13)
JUMP *ngType IF LI003>5
JUMP *ngType IF LI003<0
' 
' NOT USED
'GETARG LRXXX IARG#(14)
' 
' 
' 
'gap size output
GETARG LI005 IARG#(15)
JUMP *NOGAP IF LI005=0
JUMP *ngGap IF LI005<0
JUMP *ngGap IF LI005>99
' toolsight variables
JUMP *SETUP_NG IF LI005=22
JUMP *SETUP_NG IF LI005=23
JUMP *SETUP_NG IF LI005=24
JUMP *SETUP_NG IF LI005=25
JUMP *SETUP_NG IF LI005=32
JUMP *SETUP_NG IF LI005=33
JUMP *SETUP_NG IF LI005=34
JUMP *SETUP_NG IF LI005=35
JUMP *SETUP_NG IF LI005=36
JUMP *SETUP_NG IF LI005=37
JUMP *SETUP_NG IF LI005=38
JUMP *SETUP_NG IF LI005=39
*NOGAP
' 
'--------------------------------
'--------------------------------
'--- Begin
'--------------------------------
' 
SMOVL LP001 V=LI000 PL=0  +MOVJ LEX001
' 
JUMP *first5D IF LB004=1
JUMP *first5D IF LI003>3
JUMP *first3D
*first5D
' 
'--------------------------------
'--- 4 searches to FirstDetect
'--------------------------------
' 
' Start point
' Copy of LP001
SET LP011 LP001
SET LP006 LP001
' 
' Reference point 1
' Two copies of LP002
SET LP012 LP002
' 
' Reference point 2
' Copy of LP003
SET LP013 LP003
SET LP007 LP003
' 
' Touch 1
SET LP021 LP002
WAIT IN#(LI007)=OFF T=3.00
JUMP *CHK_NG IF IN#(LI007)=ON
SMOVL LP021 V=LI001 SRCH RIN#(LI004)=ON T=0.10 DIS=LD001  +MOVJ LEX001
GETS LB002 $B002
JUMP *BADSRCH IF LB002=0
GETS LPX021 $PX007
CNVRT LPX021 LPX021 BF
JUMP *SKIP_PF IF LB013=0
SMOVL LP001 V=LI000 PL=0  +MOVJ LEX001
' 
' Calculating offset for touch 2
' Finding vector and unitizing
SUB LP003 LP002
SET LP004 LP003
SET LB000 1
JUMP *UNITVECT
*1
' Search offset set by LD000
MUL LP004 LD000
ADD LP011 LP004
ADD LP012 LP004
' 
' Touch 2
SMOVL LP011 V=LI000 PL=0  +MOVJ LEX001
WAIT IN#(LI007)=OFF T=3.00
JUMP *CHK_NG IF IN#(LI007)=ON
SMOVL LP012 V=LI001 SRCH RIN#(LI004)=ON T=0.10 DIS=LD001  +MOVJ LEX001
GETS LB002 $B002
JUMP *BADSRCH IF LB002=0
GETS LPX022 $PX007
CNVRT LPX022 LPX022 BF
SMOVL LP001 V=LI000 PL=0  +MOVJ LEX001
' 
' Calculating offset for touch 3
' Cross product of offset 1
'   vector and touch 1 vector
' 
' Copying contents
SET LP018 LP001
SET LP019 LP002
SET LP010 LP021
' Calculating touch 1 vector
'   and unitizing
SUB LP010 LP001
SET LP004 LP010
SET LB000 2
JUMP *UNITVECT
*2
' Calculating vector of offset
'     from touch 2
SUB LP011 LP001
SET LP005 LP011
' 
' Finding cross product of
'     offset 1 and touch 1
SET LB000 3
JUMP *CROSPROD
*3
' Unitizing cross product vector
SET LB000 4
JUMP *UNITVECT
*4
' Search offset
MUL LP004 LD000
SUB LP018 LP004
SUB LP019 LP004
' 
' Touch 3
SMOVL LP018 V=LI000 PL=0  +MOVJ LEX001
WAIT IN#(LI007)=OFF T=3.00
JUMP *CHK_NG IF IN#(LI007)=ON
SMOVL LP019 V=LI001 SRCH RIN#(LI004)=ON T=0.10 DIS=LD001  +MOVJ LEX001
GETS LB002 $B002
JUMP *BADSRCH IF LB002=0
GETS LPX023 $PX007
CNVRT LPX023 LPX023 BF
SMOVL LP001 V=LI000 PL=0  +MOVJ LEX001
' 
JUMP *NOFRAME IF LB007=0
' 
MFRAME UF#(LB007) LPX021 LPX022 LPX023
' 
*NOFRAME
' 
' Calculating vector from touch 1
'    to touch 2 and vector from
'       touch 1 to touch 3
SUB LP022 LP021
SET LP004 LP022
SUB LP023 LP021
SET LP005 LP023
SET LB000 5
JUMP *CROSPROD
*5
SET LB000 6
JUMP *UNITVECT
*6
' Touch 4
MUL LP004 100
' Save perpVector to LP9
SET LP009 LP004
SUB LP001 LP004
WAIT IN#(LI007)=OFF T=3.00
JUMP *CHK_NG IF IN#(LI007)=ON
SMOVL LP001 V=LI001 SRCH RIN#(LI004)=ON T=0.10 DIS=LD001  +MOVJ LEX001
GETS LB002 $B002
JUMP *BADSRCH IF LB002=0
GETS LPX024 $PX007
CNVRT LPX024 LPX024 BF
SET LP021 LP024
SET LP025 LP024
JUMP *contEdge IF LB004<>1
*SKIP_PF
' 
'Teach Mode 1 complete
' 
MSG "Modify RefPoint 2,set TEACH to 2"
TIMER T=8.00
PAUSE
RET
' 
'--------------------------------
'--- 1 search to FirstDetect
'--------------------------------
' 
*first3D
' 
' Start point
' Copy of LP001
SET LP006 LP001
' 
' Reference point 2
' Copy of LP003
SET LP013 LP003
SET LP007 LP003
' 
WAIT IN#(LI007)=OFF T=3.00
JUMP *CHK_NG IF IN#(LI007)=ON
SMOVL LP002 V=LI001 SRCH RIN#(LI004)=ON T=0.10 DIS=LD001  +MOVJ LEX001
GETS LB002 $B002
JUMP *BADSRCH IF LB002=0
GETS LPX024 $PX007
CNVRT LPX024 LPX024 BF
SET LP021 LP024
SET LP025 LP024
TIMER T=0.50
' 
'--------------------------------
'--------------------------------
'--- Begin Search for Edge
'--------------------------------
' 
*contEdge
JUMP *step IF LI003=0
JUMP *step IF LI003=2
JUMP *step IF LI003=4
JUMP *noStep
' 
'--------------------------------
'--- Step to Edge
'--------------------------------
' 
*step
' 
' Copy newRefPt 1
SET LP008 LP024
SET LP011 LP024
SET LP012 LP024
' Copy start
SET LP009 LP006
' Copy RefPt 2
SET LP010 LP013
' 
SUB LP010 LP008
' LP10 vector is from
'  newRP1 to RP2
SUB LP009 LP008
MUL LP009 -1
' LP9 vector is from
'  Start to newRP1
SET LP004 LP009
' LP4 is normal to surface
SET LB000 16
JUMP *UNITVECT
*16
SET LP028 LP004
MUL LP028 LD002
DIV LP028 10
' save LP28 (depth vector)
'   for edgeNormal
' 
MUL LP004 LD002
SET LP014 LP004
SET LP030 LP004
' LP14 is vertical step amount
' 
' Projecting LP10 onto LP9
SET LP004 LP010
SET LP005 LP009
SET LB000 7
JUMP *PROJECT
*7
' Finding vector parallel to
'   the surface
SUB LP010 LP004
' LP10 is vector parallel
'   to the surface
' 
' Calc StepAmounts
SET LP004 LP010
SET LB000 13
JUMP *UNITVECT
*13
SET LP010 LP004
MUL LP010 LD002
SET LP011 LP010
' LP10 is horiz offset from edge
' 
SET LP004 LP009
SET LB000 15
JUMP *UNITVECT
*15
SET LP009 LP004
MUL LP009 LD002
MUL LP009 -1
ADD LP009 LP010
' LP9 is diagStep
' 
'calc dist to edge
SET LP006 LP007
SUB LP006 LP021
SET LP004 LP006
SET LB000 25
JUMP *UNITVECT
*25
SET LD023 LD010
SET LP023 LP021
' 
' Begin Step Motion
' 
*LOOP
'qualify with max shft amount
SET LP015 LP023
SUB LP023 LP021
SET LP004 LP023
SET LB000 22
JUMP *UNITVECT
*22
JUMP *CONTINUE IF LD010<LD023
'searching past edge
SUB LP015 LP007
SET LP004 LP015
SET LB000 23
JUMP *UNITVECT
*23
JUMP *MAXSHIFT IF LD010>=LD014
' 
*CONTINUE
' 
ADD LP024 LP009
SET LP022 LP024
SMOVL LP024 V=LI000 PL=0  +MOVJ LEX001
SET LP020 LP024
SET LP022 LP024
ADD LP020 LP014
WAIT IN#(LI007)=OFF T=1.00
JUMP *CHK_NG IF IN#(LI007)=ON
SMOVL LP020 V=LI001 PL=0 SRCH RIN#(LI004)=ON T=0.10 DIS=LD003  +MOVJ LEX001
GETS LB002 $B002
GETS LPX024 $PX007
CNVRT LPX024 LPX024 BF
SET LP023 LP024
JUMP *ENDFOUND IF LB002=0
JUMP *LOOP
' 
*ENDFOUND
' 
'--------------------------------
' Search for edge face
'--------------------------------
' 
*edgeFace
SET LP019 LP024
SET LP006 LP010
MUL LP010 -1
ADD LP024 LP010
WAIT IN#(LI007)=OFF T=1.00
JUMP *CHK_NG IF IN#(LI007)=ON
SMOVL LP024 V=LI001 SRCH RIN#(LI004)=ON T=0.10 DIS=LD001  +MOVJ LEX001
GETS LB002 $B002
JUMP *BADSRCH IF LB002=0
GETS LPX024 $PX002
CNVRT LPX024 LPX024 BF
SET LP017 LP024
' 
JUMP *edgeNorm IF LB004=2
JUMP *gap
' 
'--------------------------------
'--- NoStep to Edge
'--------------------------------
' 
*noStep
' 
' Copy newRefPt 1
SET LP008 LP024
SET LP011 LP024
SET LP012 LP024
SET LP022 LP024
' Copy start
SET LP009 LP006
' Copy RefPt 2
SET LP010 LP013
' 
SUB LP010 LP008
' LP10 vector is from
'  newRP1 to RP2
SUB LP009 LP008
MUL LP009 -1
' LP9 vector is from
'  Start to newRP1
SET LP004 LP009
' LP4 is normal to surface
SET LB000 27
JUMP *UNITVECT
*27
MUL LP004 LD003
SET LP021 LP004
DIV LP021 10
SET LP028 LP021
' LP21 is depth vector
SET LP028 LP021
' save LP28 for edgeNormal
' 
' Projecting LP10 onto LP9
SET LP004 LP010
SET LP005 LP009
SET LB000 28
JUMP *PROJECT
*28
' Finding vector parallel to
'   the surface
SUB LP010 LP004
SET LP020 LP010
SET LP006 LP010
' LP20 is vector parallel
'   to the surface
' 
' Calc edge offset amount
SET LP004 LP010
SET LB000 29
JUMP *UNITVECT
*29
SET LP010 LP004
MUL LP010 LD002
SET LP011 LP010
' LP10 is horiz offset from edge
' 
ADD LP024 LP021
ADD LP020 LP024
SMOVL LP024 V=LI000 PL=0  +MOVJ LEX001
TIMER T=0.50
JUMP *MAX1
WAIT IN#(LI007)=ON T=1.00
JUMP *CHK_NG IF IN#(LI007)=OFF
*MAX1
SMOVL LP020 V=LI001 PL=0 SRCH RIN#(LI004)=OFF DIS=LD001  +MOVJ LEX001
TIMER T=0.50
GETS LB002 $B002
JUMP *BADSRCH IF LB002=0
GETS LPX024 $PX007
CNVRT LPX024 LPX024 BF
SET LP019 LP024
SET LP018 LP024
SET LP017 LP024
SET LP022 LP024
ADD LP022 LP010
SET LP023 LP024
ADD LP018 LP010
MUL LP010 -1
SMOVL LP018 V=LI000 PL=1  +MOVJ LEX001
' 
JUMP *edgeNorm IF LB004=2
JUMP *calcShft IF LI003<>3
' 
'--------------------------------
' Search for gap width
'--------------------------------
' 
*gap
JUMP *calcShft IF LI003<2
JUMP *calcShft IF LI003>3
' 
SMOVL LP019 V=LI000 PL=0  +MOVJ LEX001
*skiplp19
SET LP015 LP019
' 
ADD LP015 LP006
WAIT IN#(LI007)=OFF T=3.00
JUMP *CHK_NG IF IN#(LI007)=ON
SMOVL LP015 V=LI001 SRCH RIN#(LI004)=ON T=0.10 DIS=LD001  +MOVJ LEX001
GETS LB002 $B002
JUMP *BADSRCH IF LB002=0
GETS LPX018 $PX002
CNVRT LPX018 LPX018 BF
' 
' 
' Finding vector between points
SUB LP018 LP024
' Unitizing start vector
SET LP004 LP018
SET LB000 24
JUMP *UNITVECT
' 
*24
SET LD016  EXPRESS LD010 / 2
ADD LD016 1
MUL LP004 LD016
DIV LP004 1000
SET LP016 LP004
SET LP017 LP024
ADD LP017 LP016
SET D[LI005] LD010
ADD D[LI005] LD022
SMOVL LP017 V=LI000 PL=0  +MOVJ LEX001
JUMP *calcShft IF LB004=0
' 
MSG "Modify RefPoint3; set Teach to 0"
TIMER T=8.00
PAUSE
' 
JUMP *calcShft IF LB004=0
' 
'--------------------------------
'--- Autoteach for Edge Normal
'--------------------------------
' 
*edgeNorm
JUMP *noNorm IF LD002=0
' 
JUMP *NOTEACH IF LB004=0
' 
' Find RefPt2 perpindicular
' 
' calc newRef1
SET LP023 LP024
ADD LP023 LP011
' copy new ref1
SET LP008 LP023
SET LP011 LP023
SET LP012 LP023
' copy new start offset
MUL LP009 -1
' copy new ref2
SET LP010 LP024
SET LP012 LP024
' 
' Touch 1
SMOVL LP011 V=LI007 PL=0  +MOVJ LEX001
TIMER T=1.00
SMOVL LP012 V=LI001 SRCH RIN#(LI004)=ON DIS=LD001  +MOVJ LEX001
GETS LB002 $B002
JUMP *BADSRCH IF LB000=0
GETS LPX021 $PX001
CNVRT LPX021 LPX021 BF
SMOVL LP011 V=LI007 PL=0  +MOVJ LEX001
TIMER T=0.40
' 
' Finding vector between points
SET LP013 LP011
SUB LP013 LP021
' Unitizing start vector
SET LP004 LP009
SET LB000 30
JUMP *UNITVECT
' 
*30
' Cross product of start vector
'  and vector parallel to surface
SET LP005 LP013
SET LB000 32
JUMP *CROSPROD
' 
*32
SET LB000 33
JUMP *UNITVECT
' 
*33
' Adding search offset
SET LP014 LP011
MUL LP004 LD000
ADD LP014 LP004
ADD LP012 LP004
' 
' Touch 2
SMOVL LP014 V=LI007 PL=1  +MOVJ LEX001
TIMER T=0.40
SMOVL LP012 V=LI001 SRCH RIN#(LI004)=ON DIS=LD001  +MOVJ LEX001
GETS LB002 $B002
JUMP *BADSRCH IF LB002=0
GETS LPX022 $PX001
CNVRT LPX022 LPX022 BF
SMOVL LP014 V=LI007 PL=1  +MOVJ LEX001
' 
' Find perp. search direction
' Copying contents
SET LP023 LP021
SET LP020 LP022
SET LP015 LP011
' 
' Vector from orginalTouch4
'   to start of Touch1
SET LP004 LP025
' adding depth vector...
ADD LP004 LP028
SUB LP004 LP011
' Finding vector between touches
SUB LP020 LP023
SET LP005 LP020
SET LB000 34
' Projecting ref 2 vector on to
'    touch vector
JUMP *PROJECT
*34
' 
' Creating startsearch point
ADD LP011 LP004
' 
' Touch 3
SMOVL LP011 V=LI007 PL=1  +MOVJ LEX001
TIMER T=0.40
SMOVL LP025 V=LI001 SRCH RIN#(LI004)=ON DIS=LD001  +MOVJ LEX001
TIMER T=0.20
' 
*noNorm
'original code below
GETS LPX021 $PX002
CNVRT LPX021 LPX021 BF
SET LP017 LP021
JUMP *gap IF LI003=2
JUMP *gap IF LI003=3
' 
' 
MSG "Modify RefPoint3; set Teach to 0"
TIMER T=8.00
PAUSE
RET
' 
'--------------------------------
'--- Playback shift calc
'--------------------------------
' 
*calcShft
*NOTEACH
MSG ""
JUMP *noMove IF LI003=2
JUMP *noMove IF LI003=3
SMOVL LP022 V=LI000 PL=0  +MOVJ LEX001
*noMove
SUB LP017 LP007
JUMP *FINTOUCH
' 
'--------------------------------
'--------------------------------
'--------------------------------
'--- Functions
'--------------------------------
' 
'P4 is original vector i
'P5 is original vector j
'LD 5,6,7,8,9,10,11,12,13
'LP 4,5
'LR 5,6,7,8,9,10,11,12,13,14
*CROSPROD
GETE LD005 LP004 (1)
GETE LD006 LP004 (2)
GETE LD007 LP004 (3)
SET LR005 LD005
SET LR006 LD006
SET LR007 LD007
'd8 d9 d10 are j vector
GETE LD008 LP005 (1)
GETE LD009 LP005 (2)
GETE LD010 LP005 (3)
SET LR008 LD008
SET LR009 LD009
SET LR010 LD010
'X component LR11
SET LR013 LR006
SET LR014 LR007
MUL LR013 LR010
MUL LR014 LR009
SUB LR013 LR014
SET LR011 LR013
'Y component LR12
SET LR015 LR005
SET LR014 LR007
MUL LR015 LR010
MUL LR014 LR008
SUB LR014 LR015
SET LR012 LR014
'Z component LR13
MUL LR005 LR009
MUL LR006 LR008
SUB LR005 LR006
SET LD011 LR011
SET LD012 LR012
SET LD013 LR005
DIV LD011 1000
DIV LD012 1000
DIV LD013 1000
SETE LP004 (1) LD011
SETE LP004 (2) LD012
SETE LP004 (3) LD013
'LP4 is cross product vect k
JUMP LABEL: LB000
' 
'LP4 is original vector
'Calculates LD10 as Vector length
'- ver. 2.0: microns not mm
'LD 5,6,7,10
'LP 4
'LR 5,6,7,8,9
*UNITVECT
GETE LD005 LP004 (1)
GETE LD006 LP004 (2)
GETE LD007 LP004 (3)
SET LR005 LD005
SET LR006 LD006
SET LR007 LD007
SET LR008 LR005
SET LR009 LR006
MUL LR008 LR008
MUL LR009 LR009
ADD LR008 LR009
SQRT LR008 LR008
SET LR009 LR007
MUL LR008 LR008
MUL LR009 LR009
ADD LR008 LR009
SQRT LR008 LR008
'R8=vector length
SET LD010 LR008
JUMP *uvecZero IF LR008=0
DIV LR005 LR008
DIV LR006 LR008
DIV LR007 LR008
JUMP *uvecNot0
*uvecZero
SET LR005 0
SET LR006 0
SET LR007 0
*uvecNot0
MUL LR005 1000
MUL LR006 1000
MUL LR007 1000
SET LD005 LR005
SET LD006 LR006
SET LD007 LR007
SETE LP004 (1) LD005
SETE LP004 (2) LD006
SETE LP004 (3) LD007
SETE LP004 (4) 0
SETE LP004 (5) 0
SETE LP004 (6) 0
SETE LP004 (7) 0
JUMP LABEL: LB000
' 
*PROJECT
'LP4 is vector to project
'LP5 is vector to project on to
'LD 5,6,7,8,9,10
'LP 4,5
'LR 5,6,7,8,9,10,11
GETE LD005 LP004 (1)
GETE LD006 LP004 (2)
GETE LD007 LP004 (3)
GETE LD008 LP005 (1)
GETE LD009 LP005 (2)
GETE LD010 LP005 (3)
SET LR005 LD005
SET LR006 LD006
SET LR007 LD007
SET LR008 LD008
SET LR009 LD009
SET LR010 LD010
'Dot product
MUL LR005 LR008
MUL LR006 LR009
MUL LR007 LR010
SET LR011 LR005
ADD LR011 LR006
ADD LR011 LR007
SET LR005 LR008
SET LR006 LR009
SET LR007 LR010
MUL LR005 LR005
MUL LR006 LR006
MUL LR007 LR007
ADD LR005 LR006
ADD LR005 LR007
'LD5 is square of LP5
JUMP *projZero IF LR005=0
DIV LR011 LR005
JUMP *projNot0
*projZero
SET LR011 0
*projNot0
MUL LR008 LR011
MUL LR009 LR011
MUL LR010 LR011
SET LD008 LR008
SET LD009 LR009
SET LD010 LR010
SETE LP004 (1) LD008
SETE LP004 (2) LD009
SETE LP004 (3) LD010
'LP4 is projected vector
JUMP LABEL: LB000
' 
*CHK_NG
DOUT OT#(LI007) OFF
PULSE OT#(LI012) T=0.50
PAUSE
' 
*ngType
MSG "Set Type between 0 - 5"
PULSE OT#(LI010) T=0.50
PAUSE
RET
' 
*ngTeach
MSG "Set TeachMode to 0, 1 or 2"
PULSE OT#(LI010) T=0.50
PAUSE
RET
' 
*ngAteach
MSG "Set autoTeach to 1 - 100"
PULSE OT#(LI010) T=0.50
PAUSE
RET
' 
*ngSpeed
MSG "Set SearchSpeed to 1 - 1000cm/mn"
PULSE OT#(LI010) T=0.50
PAUSE
RET
' 
*ngSpeed2
MSG "Set Air Speed to 1 - 3000cm/mn"
PULSE OT#(LI010) T=0.50
PAUSE
RET
' 
*ngDepth
MSG "Set Depth between 1 - 20mm"
PULSE OT#(LI010) T=0.50
PAUSE
RET
' 
*ngDist
MSG "Set SearchDistance to 1 - 100mm"
PULSE OT#(LI010) T=0.50
PAUSE
RET
' 
*ngOutP
MSG "Set ShiftVariable between 0-127"
PULSE OT#(LI010) T=0.50
PAUSE
RET
' 
*ngStep
MSG "Set StepOffset between 0 - 100mm"
PULSE OT#(LI010) T=0.50
PAUSE
RET
' 
*ngGap
MSG "Set GapSize between 0 - 99"
PULSE OT#(LI010) T=0.50
PAUSE
RET
' 
*ngRIN
MSG "Set RapidInput# between 1 - 5"
PULSE OT#(LI010) T=0.50
PAUSE
RET
' 
*ngRobot
MSG "Set Robot# between 1 - 4"
PULSE OT#(LI010) T=0.50
PAUSE
RET
' 
*ngLaser
MSG "Set Laser# between 0 - 5"
PULSE OT#(LI010) T=0.50
PAUSE
RET
' 
*ngSpdtyp
MSG "Set Speed Type between 1 - 4"
PULSE OT#(LI010) T=0.50
PAUSE
RET
' 
*ngPos
MSG "check register position"
PULSE OT#(LI010) T=0.50
PAUSE
RET
' 
*ngPlane
MSG "Set Plane# between 1 - 3"
PULSE OT#(LI010) T=0.50
PAUSE
RET
' 
*ngFrame
MSG "Set Userframe # between 0 - 64"
PULSE OT#(LI010) T=0.50
PAUSE
RET
' 
*ngGapAdj
MSG "Set gap between 0 - 5000 microns"
PULSE OT#(LI010) T=0.50
PAUSE
RET
' 
*BADSRCH
DOUT OT#(LI007) OFF
MSG "No Surface Detected"
JUMP *CHCKMODE IF IN#(2023)=ON
PULSE OT#(LI011) T=0.50
PAUSE
*CHCKMODE
RET
' 
*MAXSHIFT
MSG "Maximum Shift Amount Exceeded"
PULSE OT#(LI011) T=0.50
PAUSE
RET
' 
*FINTOUCH
SET LP004 LP017
SET LB000 20
JUMP *UNITVECT
*20
JUMP *MAXSHIFT IF LD010>=LD014
SETE LP017 (4) 0
SETE LP017 (5) 0
SETE LP017 (6) 0
CONVSFT LP017 LP017 LPX000 MTF
SET P[LI002] LP017
DOUT OT#(LI007) OFF
RET IF LI004<>LI013
DOUT OT#(LI014) OFF
DOUT OT#(21) OFF
TIMER T=0.20
'--------------------------------
'NEW LOGIC FOR THE OPTIONAL RETRY
'--------------------------------
IFTHEN LB014>=1
	 INC LB015
	 GETE LD016 LP017 (1)
	 GETE LD017 LP017 (2)
	 GETE LD018 LP017 (3)
	 SET LB017 0
	 SET LB018 0
	'--------------------------------
	'--------------------------------
	 IFTHEN LD016>=LD015 ANDIF LD016>=LD019 ANDIF LB015>=LB014
		 MSG "MAX RETRY COUNT HAVE BEEN REACH"
		 TIMER T=8.00
		 PAUSE
		 RET
	 ENDIF
	 IFTHEN LD017>=LD015 ANDIF LD017>=LD019 ANDIF LB015>=LB014
		 MSG "MAX RETRY COUNT HAVE BEEN REACH"
		 TIMER T=8.00
		 PAUSE
		 RET
	 ENDIF
	 IFTHEN LD018>=LD015 ANDIF LD018>=LD019 ANDIF LB015>=LB014
		 MSG "MAX RETRY COUNT HAVE BEEN REACH"
		 TIMER T=8.00
		 PAUSE
		 RET
	 ENDIF
	 IFTHEN LD016<=LD015 ANDIF LD016<=LD019 ANDIF LB015>=LB014
		 MSG "MAX RETRY COUNT HAVE BEEN REACH"
		 TIMER T=8.00
		 PAUSE
		 RET
	 ENDIF
	 IFTHEN LD017<=LD015 ANDIF LD017<=LD019 ANDIF LB015>=LB014
		 MSG "MAX RETRY COUNT HAVE BEEN REACH"
		 TIMER T=8.00
		 PAUSE
		 RET
	 ENDIF
	 IFTHEN LD018<=LD015 ANDIF LD018<=LD019 ANDIF LB015>=LB014
		 MSG "MAX RETRY COUNT HAVE BEEN REACH"
		 TIMER T=8.00
		 PAUSE
		 RET
	 ENDIF
	'--------------------------------
	'--------------------------------
	 JUMP *RETRY IF LD016>=LD015
	 JUMP *RETRY IF LD017>=LD015
	 JUMP *RETRY IF LD018>=LD015
	 JUMP *RETRY IF LD016<=LD019
	 JUMP *RETRY IF LD017<=LD019
	 JUMP *RETRY IF LD018<=LD019
ENDIF
RET
' 
'----------------------
'- Please contact Jack
'- Moore of the TAT
'- to report bugs.
'----------------------
END
